# Архитектура чат-бота на Flowise

Документ фиксирует **эталонную архитектуру чат-бота**, проверенную на практике.
Может использоваться как:
- дорожная карта для будущих проектов
- техническое ТЗ для разработчиков
- опорный документ при масштабировании

---

## 1. Общая концепция

Бот построен по принципу **жёсткого разделения ответственности**:

- Flowise — только логика диалога ("мозг")
- Backend — только приём и обработка заявок
- Widget — только UI (исполнение)
- nginx — единственная точка маршрутизации

Flowise **не знает**:
- куда уходят заявки
- как они обрабатываются
- есть ли CRM / email / Telegram

Backend **не знает**:
- что такое Flowise
- какие сценарии у бота
- как выглядит интерфейс

---

## 2. Инфраструктура

### 2.1 VPS

- Один VPS (IP: `166.1.221.146`)
- Установлены:
  - Docker
  - nginx
  - Flowise (AgentFlow V2)
  - Backend заявок (Node.js + Express)

VPS выполняет роль **универсальной серверной платформы**.

---

### 2.2 Docker

Каждый компонент — отдельный контейнер:

- `flowise` — логика бота
- `cesi-backend` — приём заявок
- (опционально) `chroma` — векторная БД для RAG

Контейнеры независимы и могут обновляться отдельно.

**RAG (Flowise + Chroma):** Контейнеры Flowise и Chroma **должны находиться в одной Docker-сети**. Без общей сети векторное хранилище не работает, при этом приложения не показывают явных ошибок — RAG просто перестаёт отдавать результаты. При развёртывании Chroma обязательно подключать его к той же сети, что и Flowise.

---

### 2.3 Flowise

Flowise используется **только как мозг бота** (логика диалога).

**Принципы работы:**
- Flowise **не вызывает** backend
- Flowise **не использует** HTTP-ноды для заявок
- Flowise использует **только Prediction API** (диалог)

**В Flowise реализованы:**
- логика диалога
- системный промпт
- RAG на базе markdown-файлов (опционально с векторной БД `chroma`)

Детальная структура AgentFlow V2, список нод и принципы настройки описаны в `flowise.md`. Мы работаем в **AgentFlow V2**, не в Chatflow; все ноды и правила — только из AgentFlow V2.

**Доступ:**
- Доступ к Flowise осуществляется по HTTPS через nginx (reverse proxy)
- Встроенный Flowise-виджет **не используется**

---

## 3. Домены и DNS

### 3.1 DNS

- Домен: `bot.jeeptour41.ru`
- A-запись указывает на VPS (`166.1.221.146`)
- DNS-регистратор (reg.ru) используется **только для DNS**, не как хостинг

---

### 3.2 Роль домена

`bot.jeeptour41.ru` — единая публичная точка доступа для:

- Flowise API
- Flowise UI
- Статики виджета
- Backend заявок (через nginx)

---

## 4. nginx — ключевой элемент архитектуры

nginx выполняет **две критические роли**:

1. Reverse proxy
2. Контроль внешних контрактов

Вся внешняя логика **завязана на nginx**, а не на Flowise или backend.

---

## 5. Маршрутизация (финальная, рабочая схема)

### 5.1 Статика виджета

```
/widget/*  →  /var/www/html/widget/
```

- HTML / JS / CSS
- nginx просто отдаёт файлы
- логики нет

---

### 5.2 Flowise API (КРИТИЧНО)

```
/api/*  →  flowise:3000
```

Используется для:
- UI Flowise
- AgentFlow V2 (поток бота; не Chatflow)
- сообщений бота
- авторизации

⚠️ Этот маршрут **нельзя занимать под backend**.

---

### 5.3 Flowise UI

```
/  →  flowise:3000
```

- Админка
- Настройка ботов

---

### 5.4 Backend заявок (публичный контракт)

```
/lead/send-lead  →  cesi-backend:3001/api/send-lead
```

- Единственная публичная точка заявок
- nginx выполняет точечный proxy

**⚠️ CORS обязателен:** виджет подключается на **внешних сайтах** (другой домен). Запросы к `/lead/send-lead` идут cross-origin. Без CORS и обработки OPTIONS (preflight) браузер блокирует запрос до отправки → `Failed to fetch`, заявки не доходят до backend. В nginx для этого location должны быть:
- `add_header Access-Control-Allow-Origin "*" always;`
- `add_header Access-Control-Allow-Methods "POST, OPTIONS" always;`
- `add_header Access-Control-Allow-Headers "Content-Type" always;`
- при `$request_method = OPTIONS` — `return 204;` (preflight).

Подробный разбор инцидента и чек-лист — см. раздел 12 ниже.

---

## 6. Backend заявок

### 6.1 Назначение

Backend:
- принимает заявку
- валидирует данные
- отправляет email / CRM / Telegram

Flowise **не участвует** в этом процессе.

---

### 6.2 Контракт backend

**Внутренний endpoint:**
```
POST /api/send-lead
```

**Публичный endpoint:**
```
POST https://bot.jeeptour41.ru/lead/send-lead
```

**Payload:**
```json
{
  "name": "string",
  "phone": "string",
  "message": "string (optional)"
}
```

**Response:**
```json
{ "success": true }
```

---

## 7. Виджет (Frontend)

### 7.1 Принципы

Виджет:
- универсальный
- переиспользуемый
- без бизнес-логики

Он:
- показывает UI
- отправляет сообщения в Flowise
- отправляет заявки в backend

---

### 7.2 Подключение на сайт

```html
<script src="https://bot.jeeptour41.ru/widget/widget.js"></script>
```

Один и тот же виджет может использоваться на любом сайте.

---

## 8. Поток данных (человеческая схема)

```
Пользователь
   ↓
Виджет (JS)
   ↓
Flowise (логика диалога)
   ↓
[решение оставить заявку]
   ↓
/lead/send-lead
   ↓
Backend (Express)
   ↓
Email / CRM
```

---

## 9. Ключевые архитектурные принципы (ЗАФИКСИРОВАТЬ)

1. Flowise ≠ backend
2. Flowise не отправляет заявки
3. Backend не знает Flowise
4. nginx — единственная точка внешних контрактов
5. Все внешние URL стабильны
6. Внутренние пути можно менять без влияния на фронт
7. Идентификатор потока AgentFlow V2 — технический идентификатор, не контракт

---

## 10. Практические выводы

- Архитектура устойчива к ошибкам UI
- Можно менять Flowise без влияния на заявки
- Можно менять backend без влияния на бота
- Можно масштабировать систему по частям

---

## 11. Рекомендации для будущих проектов

- ❌ не использовать `flowise:latest`
- ✅ фиксировать версию Flowise
- ✅ делать backup `database.sqlite`
- ✅ документировать nginx-контракты
- ✅ разделять диалог и бизнес-логику
- ✅ для любого публичного виджета: **сразу** настраивать CORS + OPTIONS для POST-endpoint'ов (см. раздел 12)
- ✅ в nginx **не держать** несколько server-блоков с одним `server_name` (конфликт, нестабильное поведение)

---

## 12. Виджет на внешних сайтах: CORS и nginx

Виджет подключается так:
```html
<script src="https://bot.jeeptour41.ru/widget/widget.js"></script>
```
Скрипт выполняется в контексте **сайта-клиента** (другой домен). Запросы к `bot.jeeptour41.ru` (Flowise API, `/lead/send-lead`) — cross-origin. Браузер требует CORS.

### 12.1 Что обязательно в nginx для `/lead/send-lead`

- **CORS-заголовки** на ответах (в т.ч. при ошибках — использовать `always`).
- **Обработка OPTIONS** (preflight): для запроса с методом OPTIONS возвращать `204` с теми же CORS-заголовками, без проксирования на backend.

Без этого: в DevTools запрос может быть «0.0 kB», без HTTP-статуса, в nginx access.log и логах backend запроса нет — браузер обрывает запрос до HTTP-уровня. В коде виджета — `TypeError: Failed to fetch`.

### 12.2 Чего избегать

- **Дублирующиеся server-блоки** с одним `server_name` в `sites-enabled` (например `bot.jeeptour41.ru` и `bot.jeeptour41.ru.bak`). nginx выдаёт `conflicting server name ... ignored`, поведение непредсказуемо.
- Перед изменениями проверять: `grep -R "server_name bot.jeeptour41.ru" /etc/nginx/sites-enabled` — должен быть один конфиг.

### 12.3 Чек-лист при добавлении нового endpoint для виджета

1. Сразу добавить в nginx CORS-заголовки и обработку OPTIONS для этого location.
2. Убедиться, что нет второго server-блока с тем же `server_name`.
3. После правок: `nginx -t && systemctl reload nginx`.
4. Проверять не только curl, но и вызов из браузера (DevTools → Network, запрос с другого домена) и при необходимости — nginx access.log.

Подробный разбор инцидента «заявки не отправлялись (Failed to fetch)» зафиксирован в `123.md` в корне проекта.

---

**Статус документа:** эталонная архитектура, проверенная в бою


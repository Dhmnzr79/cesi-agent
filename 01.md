Цельное решение: “RAG-бот с эмпатичным диалогом и продолжением ТОЛЬКО по базе” (Flowise AgentFlow V2)
1) Цель и ограничения

Цель: бот отвечает по RAG базе и ведёт естественный диалог, предлагая продолжение только по тем аспектам, которые реально существуют в базе, без “стоматологических штампов” и обещаний того, чего нет в md.

Критическое правило: бот может предлагать продолжение только из списка current_topics, который формируется детерминированно из структуры темы (outline), а не из “головы” модели.

Контекст Flowise: только AgentFlow V2. Никаких chatflows.

2) Причина проблемы (почему сейчас бот ошибается)

Семантический Retriever (RAG) возвращает только top-k релевантных чанков, а не “всю тему/весь файл”. Поэтому если пытаться строить “о чём ещё поговорить” из retrieved-чанков:

список аспектов будет случайным и неполным

бот будет иногда предлагать “Этапы”, “Противопоказания” и т.п., даже когда их нет в базе по теме

или наоборот не предложит то, что в файле есть, но не попало в retrieval

Решение: разделить retrieval на два контура:

Retriever #1 = смысл (семантика) → факты для ответа сейчас

Retriever #2 = структура (outline) → список разрешённых продолжений

3) Организация MD-базы под current_topics
3.1 Единый стандарт заголовков

## = тема (один файл = одна тема)

### = аспект темы (подраздел, по которому бот может продолжать диалог)

Ключевой принцип: каждый ### — это “вариант продолжения”, поэтому их нельзя делать слишком много.

3.2 Три типа файлов (под твою логику)

Файлы делятся на 3 типа (тип задаётся либо по префиксу имени файла, либо строкой TYPE: внутри файла):

reference — один блок/абзац по теме (контакты, адрес, график)

### либо отсутствуют, либо только ### Коротко

продолжение по теме обычно не предлагается (только “ещё вопросы?”/“помочь с записью?”)

compact — тема среднего объёма, максимум 2 аспекта

### Коротко

### <1 важный аспект>

deep — объёмная тема, максимум 4 аспекта

### Коротко (всегда первый)

ещё 2–3 сильных аспекта (не дробить на 8 мелких)

3.3 Нормализация названий ### (чтобы current_topics был чистым)

Вводится канонический словарь H3 (использовать одни и те же формулировки, не плодить синонимы):

Базовые:

Коротко

Кому подходит

Ограничения

Этапы

Стоимость

FAQ/риски:

Если не приживётся

От чего зависит успех

Если ничего не делать

Клиника/врач:

Опыт и специализация

Подход в работе

Если в каком-то файле сейчас “Почему выбирают / Когда выбирают / Что важно учитывать” — их лучше схлопывать в 1–2 канонических аспекта, чтобы не было 4 почти одинаковых “продолжений”.

4) Outline Store (структурный индекс темы) — ключевой компонент
4.1 Почему нужен отдельный Outline Store

Чтобы бот знал, какие аспекты существуют в теме, независимо от того, какие чанки принес Retriever #1.

4.2 Как устроен Outline Store

Создаётся отдельное хранилище/коллекция (Document Store / Vector Store) OUTLINES.

Правило: 1 документ = 1 тема (1 исходный md-файл).
Контент документа — только структура (H2/H3), например:

SOURCE: impl__type_classic.md
## Классическая имплантация
### Коротко
### Кому подходит
### Ограничения
### Этапы

Для консультации:

SOURCE: clinic__consultation.md
## Бесплатная консультация
### Коротко
### Что входит в консультацию
### Кто проводит консультацию
### Диагностика

Важно: OUTLINES — не для ответа пользователю, а для детерминированного списка “что можно предложить дальше”.

5) Flowise AgentFlow V2: полный граф нод (от и до)
5.1 Flow State (Start)

В Start node объявляются переменные (минимум):

topic_source (string) — имя исходного файла темы (из metadata)

outline_text (string) — текст outline-документа

all_topics (array<string>) — все ### из outline

covered_topics (array<string>) — какие аспекты уже раскрыты в диалоге

current_topics (array<string>) — разрешённые аспекты для предложения сейчас

topic_type (string) — reference|compact|deep (по имени файла или по TYPE в outline)

5.2 Ноды и логика
Node A — LLM Rewriter

Input: {{question}} + short memory window (например 4–6)

Output: нормализованный поисковый запрос (string)
Цель: убрать “Да/угу/ок” и сделать осмысленный query.

Node B — Retriever #1 (Semantic)

Query = rewriter.output

Output format = Text with Metadata

Возвращает чанки контента + metadata (нужен source/filename)

Node C — Topic Source Picker (детерминированно)

Custom Function (без LLM):

берёт metadata.source (или filename) у самого релевантного чанка

сохраняет в topic_source

Если источников несколько — выбирается первый/наиболее релевантный. Это достаточно для твоей базы “1 тема = 1 файл”.

Node D — Retriever #2 (Outline)

Store = OUTLINES

Query = topic_source (или SOURCE: <topic_source>)

TopK = 1

Output: outline_text

Node E — Header Extractor (детерминированно)

Custom Function (regex, без LLM):

из outline_text достаёт все строки ### ...

нормализует пробелы/регистр/дубликаты

сохраняет в all_topics

Также на этом шаге можно определить topic_type:

по topic_source префиксу (clinic__/impl__/doctor__/faq__)
или

по строке TYPE: в outline (если ты её добавишь)

Node F — Covered Topics Tracker (LLM, но строго ограниченно)

LLM нода, задача — не “придумывать”, а классифицировать:

Input: последние N сообщений диалога (Memory Window 6–10) + all_topics

Output: JSON строго вида:
{ "covered_topics": ["...","..."] }
Правило: covered_topics может содержать только элементы из all_topics.

Node G — Current Topics Builder (детерминированно)

Custom Function:

current_topics = all_topics - covered_topics

затем применить лимит отображения:

если current_topics.length > 2 → оставить топ-2 наиболее логичных (можно по фиксированному приоритету: Этапы > Ограничения > Кому подходит > Стоимость)

либо отдавать все, но UI предлагать 2 (рекомендуется 2)

Node H — Final LLM (Answer)

Final LLM получает:

retrieved chunks (Retriever #1)

topic_source, topic_type, current_topics

правила (System prompt)

И генерирует:

ответ строго по retrieved контенту

продолжение только из current_topics, в корректном формате (см. правила ниже)

6) Правила поведения (в System prompt) — жёсткие
6.1 Главные запреты (антигаллюцинации)

Отвечать только по retrieved (и/или базе).

Запрещено предлагать аспекты, которых нет в current_topics.

Запрещено говорить “могу рассказать про этапы/противопоказания…” если этих пунктов нет в current_topics.

Запрещено добавлять медицинские назначения/диагнозы/обещания результата.

6.2 Разные режимы для reference vs procedure

Reference темы (clinic__*, contacts, schedule, etc.)

если вопрос общий → ответить “пакетом” (несколько аспектов за раз), без “хотите узнать кто проводит”

в конце не предлагать “подробнее по теме”

допустимо завершить: “Есть ещё вопросы?” / “Подсказать, как записаться?” (если это есть в базе)

Deep/Procedure темы (impl__*)

первый ответ: “Коротко” + 1–2 факта по retrieved

затем предложить продолжение только из current_topics (1–2 варианта)

6.3 Обработка current_topics пустой — два кейса (важно)

current_topics == [] бывает по двум причинам — различать:

retrieved НЕ пустой (ответ по сути есть), но продолжений нет
→ НЕ говорить “в базе нет информации”.
→ завершить нейтрально: “Если хотите, уточню другой вопрос / помогу с записью”.

retrieved пустой или недостаточен для ответа
→ честно: “В нашей базе нет информации по этому запросу…”
→ предложить уточнить или передать администратору.

6.4 Правило “Да” без уточнения

Когда бот предложил продолжение:

если предложен 1 пункт (current_topics_shown = [X]) и пользователь пишет “да/угу/ок” → продолжить по X сразу

если предложены 2 пункта ([X,Y]) и пользователь пишет “да” → задать один уточняющий вопрос выбора “X или Y?”

7) Стиль без “шаблонных фраз” (в Developer / guide)

Чтобы не звучало роботизированно:

фиксируется структура ответа (суть → деталь → продолжение)

эмпатия максимум 1 короткая фраза, но формулируется свободно

запрещены клише (“всё индивидуально, приходите на консультацию”) как единственный ответ

продолжение формулировать вариативно, но строго по current_topics

8) Почему это решение оптимально для твоего объёма

Минимум инфраструктуры: всего один доп. store OUTLINES + второй retriever

Детерминизм: бот не гадает про “этапы”, он читает структуру темы

Контроль: продолжение возможно только из разрешённого списка

Естественность: reference темы отвечают “пакетом”, без лишних шагов

Масштабирование: база растёт → outline растёт линейно, логика не меняется

9) Требования к данным (чтобы всё работало стабильно)

Retriever #1 должен возвращать metadata с source/filename для каждого чанка.

topic_source должен совпадать с полем SOURCE в OUTLINES.

В md нужно держать максимум 4 H3 для deep тем, иначе меню продолжения раздробится.

Готово. Это цельное решение “от и до”, пригодное для обсуждения/внедрения через Cursor.